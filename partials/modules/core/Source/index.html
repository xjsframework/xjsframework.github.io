
<h1 class="class export">Source <span class="type">class</span></h1>
<p><p>A <code>Source</code> represents an object of an Item that is used on the stage.
Manipulating Source specific properties would render changes to all
items linked to that source.</p>
<h3 id="basic-usage">Basic Usage</h3>
<pre><code class="lang-javascript">var xjs = require(&#39;xjs&#39;);
var Scene = xjs.Scene

xjs.ready()
   .then(Scene.getById(1))
   .then(function(scene) {
   scene.getSources().then(function(sources) {
   return sources[0].setCustomName(&#39;Custom Name&#39;);
   })
})
</code></pre>
<p>All methods marked as <em>Chainable</em> resolve with the original <code>Source</code> instance.
This allows you to perform sequential operations correctly: *</p>
<pre><code class="lang-javascript">var xjs = require(&#39;xjs&#39;);
var Source = xjs.Source;

xjs.ready()
   .then(Source.getCurrentSource)
   .then(function(source){
    //Manipulate source here
    return source.setName(&#39;New Name&#39;);
 }).then(function(source){
    return source.setKeepLoaded(true)
 }).then(function(source){
    // set more source properties here
 })
</code></pre>
</p><h2>Members</h2>
  <section class="member constructor">
    <h1 id="constructor" class="name">constructor</h1>

  </section>

  <section class="member">
    <a name="setName"><h1 id="setName" class="name">
      setName
    </h1></a>
    <pre><code>param: (value: string)
</code></pre>
<pre><code>return: Promise&lt;Source&gt;
</code></pre>
<p>In XBC 2.8, names can be set individually even on linked items.
For XBC 2.9 onwards,  name will be the same across all linked items
to the same Source.</p>
<p><em>Chainable.</em></p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">source.setName(&#39;newNameHere&#39;).then(function(source) {
  // Promise resolves with same Source instance when name has been set
  return source.getName();
}).then(function(name) {
  // &#39;name&#39; should be the updated value by now.
});
</code></pre>

  </section>


  <section class="member">
    <a name="getName"><h1 id="getName" class="name">
      getName
    </h1></a>
    <pre><code>return: Promise&lt;string&gt;
</code></pre>
<p>Gets the name of the source.</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">source.getName().then(function(name) {
  // Do something with the name
});
</code></pre>

  </section>


  <section class="member">
    <a name="setCustomName"><h1 id="setCustomName" class="name">
      setCustomName
    </h1></a>
    <pre><code>param: (value: string)
</code></pre>
<pre><code>return: Promise&lt;Source&gt;
</code></pre>
<p>In XBC 2.8, CustomName can be set individually even on linked items.
For XBC 2.9 onwards, CustomName will be the same across all linked items
to the same Source</p>
<p>The main difference between <code>setName</code> and <code>setCustomName</code> is that the CustomName
can be edited by users using XBC through the bottom panel. <code>setName</code> on
the other hand would update the sources internal name property.</p>
<p><em>Chainable.</em></p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">source.setCustomName(&#39;newNameHere&#39;).then(function(source) {
  // Promise resolves with same Source instance when custom name has been set
  return source.getCustomName();
}).then(function(name) {
  // &#39;name&#39; should be the updated value by now.
});
</code></pre>

  </section>


  <section class="member">
    <a name="getCustomName"><h1 id="getCustomName" class="name">
      getCustomName
    </h1></a>
    <pre><code>return: Promise&lt;string&gt;
</code></pre>
<p>Gets the custom name of the source.</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">source.getCustomName().then(function(name) {
  // Do something with the name
});
</code></pre>

  </section>


  <section class="member">
    <a name="getValue"><h1 id="getValue" class="name">
      getValue
    </h1></a>
    <pre><code>return: Promise&lt;string|XML&gt;
</code></pre>
<p>Gets a special string that refers to the source&#39;s main definition.</p>
<p>This method can resolve with an XML object, which is an object generated by
the framework. Call <code>toString()</code> to transform into an XML String. (See the
documentation for <code>setValue</code> for more details.)</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">source.getValue().then(function(value) {
  // Do something with the value
});
</code></pre>

  </section>


  <section class="member">
    <a name="setValue"><h1 id="setValue" class="name">
      setValue
    </h1></a>
    <pre><code>param: (value: string)
</code></pre>
<pre><code>return: Promise&lt;Source&gt;
</code></pre>
<p>Set the sources main definition. This special string defines the sources
&quot;identity&quot;. Each type of source requires a different format for this value.</p>
<p><em>Chainable.</em></p>
<p><strong>WARNING:</strong>
Please do note that using this method COULD break the current source, possibly modifying
its type IF you set an invalid string for the current source.</p>
<h4 id="possible-values-by-source-type">Possible values by source type</h4>
<ul>
<li>FILE - path/URL</li>
<li>LIVE - Device ID</li>
<li>BITMAP - path</li>
<li>SCREEN - XML string</li>
<li>FLASHFILE - path</li>
<li>GAMESOURCE - XML string</li>
<li>HTML - path/URL or html:<plugin></li>
</ul>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">source.setValue(&#39;@DEVICE:PNP:\\?\USB#VID_046D&amp;amp;PID_082C&amp;amp;MI_02#6&amp;amp;16FD2F8D&amp;amp;0&amp;amp;0002#{65E8773D-8F56-11D0-A3B9-00A0C9223196}\GLOBAL&#39;)
  .then(function(source) {
  // Promise resolves with same Source instance
});
</code></pre>

  </section>


  <section class="member">
    <a name="getKeepLoaded"><h1 id="getKeepLoaded" class="name">
      getKeepLoaded
    </h1></a>
    <pre><code>return: Promise&lt;boolean&gt;
</code></pre>
<p>Check if source is kept loaded in memory</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">source.getKeepLoaded().then(function(isLoaded) {
  // The rest of your code here
});
</code></pre>

  </section>


  <section class="member">
    <a name="setKeepLoaded"><h1 id="setKeepLoaded" class="name">
      setKeepLoaded
    </h1></a>
    <pre><code>param: (value: boolean)
</code></pre>
<pre><code>return: Promise&lt;Source&gt;
</code></pre>
<p>Set Keep loaded option to ON or OFF</p>
<p>Sources with Keep loaded set to ON would emit <code>scene-load</code> event each time
the active scene switches to the source&#39;s current scene.</p>
<p><em>Chainable.</em></p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">source.setKeepLoaded(true).then(function(source) {
  // Promise resolves with same Source instance
});
</code></pre>

  </section>


  <section class="member">
    <a name="getId"><h1 id="getId" class="name">
      getId
    </h1></a>
    <pre><code>return: Promise&lt;string&gt;
</code></pre>
<p>Get the Source ID of the source.
<em>Available only on XSplit Broadcaster versions higher than 2.8.1603.0401</em></p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">source.getId().then(function(id) {
  // The rest of your code here
});
</code></pre>

  </section>


  <section class="member">
    <a name="getItemList"><h1 id="getItemList" class="name">
      getItemList
    </h1></a>
    <pre><code>return: Promise&lt;Item[]&gt;
</code></pre>
<p>Get the item list of the current Source/Item instance. This is useful when
a source has multiple items linked into it or if an item is an instance of
a linked item.</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">// source pertains to an actual source in....
// Sample 1
source.getItemList().then(function(items) {
  // This will fetch the linked items list of the current source
  for (var i = 0 ; i &lt; items.length ; i++) {
    // Manipulate each item here
    items[0].getSceneId();
  }
});

// Sample 2
item.getItemList().then(function(items) {
  items[0].getSceneId();
})
</code></pre>

  </section>


  <section class="member">
    <a name="refresh"><h1 id="refresh" class="name">
      refresh
    </h1></a>
     <pre><code>return: Promise&lt;Source&gt;
 </code></pre>
 <p>Refreshes the specified Source.</p>
 <h4 id="usage">Usage</h4>
 <pre><code class="lang-javascript">// Sample 1: let source refresh itself
 xjs.Source.getCurrentSource().then(function(source) {
   source.refresh(); // execution of JavaScript halts because of refresh
 });

 // Sample 2: refresh some other source &#39;otherSource&#39;
 otherSource.refresh().then(function(source) {
   // further manipulation of other source goes here
 });
 </code></pre>

  </section>


  <section class="member">
    <a name="getType"><h1 id="getType" class="name">
      getType
    </h1></a>
    <pre><code>return: Promise&lt;ItemType&gt;
</code></pre>
<p>Get the type of the source</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">source.getType().then(function(type) {
  // The rest of your code here
});
</code></pre>

  </section>


  <section class="member static">
    <a name="getCurrentSource"><h1 id="getCurrentSource" class="name">
      <code>static</code> getCurrentSource
    </h1></a>
    <pre><code>return: Promise&lt;Source&gt;
</code></pre>
<p>Get the current source (when function is called by sources), or the source
that was right-clicked to open the source properties window (when function is called
from the source properties window)</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">xjs.Source.getCurrentSource().then(function(source) {
  // This will fetch the current source (the plugin)
}).catch(function(err) {
  // Handle the error here. Errors would only occur
  // if we try to execute this method on Extension plugins
});
</code></pre>

  </section>


  <section class="member static">
    <a name="getItemList"><h1 id="getItemList" class="name">
      <code>static</code> getItemList
    </h1></a>
    <pre><code>return: Promise&lt;Item[]&gt;
</code></pre>
<p>Get the item List of the current Source.
The item list is a list of items linked to a single Source.</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">xjs.Source.getItemList()
.then(function(items) {
  // This will fetch the item list of the current Source
  for (var i = 0 ; i &lt; items.length ; i++) {
    // Manipulate each item here
  }
});
</code></pre>
<p>This is just the shorter way of getting items that are linked to a single
source. See the long version below:</p>
<pre><code class="lang-javascript">xjs.Source.getCurrentSource()
.then(source.getItemList)
.then(function(items) {
// Manipulate the items here
})
</code></pre>

  </section>


  <section class="member static">
    <a name="getAllSources"><h1 id="getAllSources" class="name">
      <code>static</code> getAllSources
    </h1></a>
    <pre><code>return: Promise&lt;Source[]&gt;
</code></pre>
<p>Get all unique Source from every scene.
Total number of Sources returned may be less than total number of items on
all the scenes due to <code>Linked</code> items only having a single Source.</p>
<h4 id="usage">Usage</h4>
<pre><code class="lang-javascript">xjs.Source.getAllSources().then(function(sources) {
  for(var i = 0 ; i &lt; sources.length ; i++) {
     if(sources[i] instanceof xjs.HtmlSource) {
       // Manipulate HTML Source here
     }
   }
})
</code></pre>

  </section>

<p class="module defined-in">exported from <a href='#/core'>core</a><br/>
defined in <a href="https://github.com/xjsframework/xjs/tree/master/modules/C:/Users/viab/Documents/Repositories/SourceTree/xjsframework/src/core/source/source.ts#L25-L528">C:/Users/viab/Documents/Repositories/SourceTree/xjsframework/src/core/source/source.ts (line 25)</a>
</p>

